I created a nodejs webapp that serves as a dashboard to manage personal life. The application, named "dashy", is a single-page web app designed to visually organize and connect various aspects of life, centered around an interactive map. It allows the creation of different types of personal data objects (like places, people, interactions, to-do, images, files and custom objects) and, most importantly, the ability to create and visualize relationships between them. The main interface is a 50/50 split screen "map" and "app", with a Leaflet 2.0+ map on one side and a dynamic content panel on the other, allowing for rich interaction between geographical data and other personal information.

Key Features
Object Creation & Management: Users can add, view, edit, and delete several types of objects, including Places, People, Interactions, To-Do items, Custom Objects, Images, and Files.
Universal Linking: The core of the app is its ability to link any object to any other object. An interaction can be linked to the people involved and the place it occurred. A person can be linked to their favorite places, photos, and custom objects like movies or recipes.
Interactive Map Interface: Places are represented as markers on a Leaflet map. Clicking a marker loads that Place's details into the content panel. When viewing any object that is linked to a Place, the map automatically centers on that location.
On-the-Fly Creation: Users can create new items seamlessly while editing or creating another. For example, when creating an Interaction, you can create a new Person to link to it without leaving the creation flow.

Automatic Image Intelligence:
GPS Geotagging: When an image with GPS metadata is uploaded, the app automatically finds the nearest existing Place and links it, or creates a new Place if none are nearby.
Date-Based Naming: The app reads the photo's creation date from its EXIF data and uses it to generate the stored filename (yyyy-mm-dd-{id}.extension) (e.g., 2024-10-23-{id}.jpg), defaulting to today if no date is found.
Conversion: Images are automatically converted with the sharp package to .JPG on upload for universal browser compatibility.
Inline & In-Place Editing: Object titles and key-value pairs can be edited directly in the object view without navigating to a separate edit page, providing a fluid user experience, as well as adding or unlinking objects in the Link list.

Data Objects
The application revolves around these core entities:
Places: An object with a title, custom key-value parameters, and geographical coordinates (lat, lng) that appear as a marker on the map.
People: An object identified by a title with custom key-value parameters.
Interactions: Represents an event. It has a title, a date, and a "mood" level (from -100 to +100). It's designed to be linked to People, Places, etc.
Images & Files: Media uploads that are stored on the server. Images are automatically processed for metadata. Files are stored as they are without processing.
Custom Objects: A flexible object type defined by the user (e.g., "Movie," "Book," "Recipe"). It has a title, a mood level, and custom key-value parameters.
To-Do items: To manage tasks, have a title and a status (0 - incomplete, 1 - complete). When incomplete, they are pinned to the top in the corresponding list views.
Technical Stack and choices
Backend: Node.js with the Express.js framework.
Database: A self-initializing SQLite database for simple, file-based persistence. No complex setup is required.
Frontend: The app is built with vanilla JavaScript (ES6 Modules) and does not rely on a large frontend framework.
Mapping: Leaflet.js (version 2.0) is used for all map functionalities.
Dependencies: Key Node.js packages include express, sqlite3, multer (for file uploads), exif-parser (for image metadata), and sharp (for image conversion).
Coding style: Organized, DRY and with debugging console logs to understand what the app is doing at all times and debug easily.
Project Structure
The project is organized into a clean structure to separate the server-side logic, public-facing assets, and user data.
app (core app items)
data (for files and database)
public (for server files)
The full files are shown below for reference:
File /package.json:
{
  "name": "dashy",
  "version": "1.0.0",
  "description": "A gamified life dashboard.",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js"
  },
  "keywords": [
    "leaflet",
    "express",
    "sqlite",
    "sharp"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "exif-parser": "^0.1.12",
    "express": "^5.1.0",
    "multer": "^2.0.1",
    "nanoid": "^5.1.5",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "sharp": "^0.34.2"
  }
}

File /server.js:
import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import { initDatabase } from './app/database.js';
import apiRouter from './app/routes.js';

// Recreate __dirname for ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const port = 3000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Serve static files
app.use(express.static(path.join(__dirname, 'public')));
app.use('/data', express.static(path.join(__dirname, 'data')));


// API Routes
app.use('/api', apiRouter);

// Main route to serve the webapp
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Initialize database and start server
initDatabase().then(() => {
    app.listen(port, () => {
        console.log(`Dashy app listening at http://localhost:${port}`);
    });
}).catch(err => {
    console.error('Failed to initialize database:', err);
    process.exit(1);
});
File /app/database.js:
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import path from 'path';

let db;

export async function initDatabase() {
    db = await open({
        filename: path.resolve('./data/dashy.sqlite3'),
        driver: sqlite3.Database
    });

    await db.exec(`
        PRAGMA foreign_keys = ON;

        CREATE TABLE IF NOT EXISTS places (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            lat REAL NOT NULL,
            lng REAL NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS people (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS images (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            file_path TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS files (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            file_path TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS interactions (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            mood INTEGER NOT NULL,
            interaction_date DATE NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS custom_objects (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            object_type TEXT NOT NULL,
            mood INTEGER NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS todos (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            status INTEGER NOT NULL DEFAULT 0, -- 0 = incomplete, 1 = complete
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS key_values (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            object_id TEXT NOT NULL,
            object_table TEXT NOT NULL,
            key TEXT NOT NULL,
            value TEXT NOT NULL
        );

        CREATE TABLE IF NOT EXISTS links (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            source_id TEXT NOT NULL,
            source_table TEXT NOT NULL,
            target_id TEXT NOT NULL,
            target_table TEXT NOT NULL,
            UNIQUE(source_id, source_table, target_id, target_table)
        );
    `);
    return db;
}

export const getDb = () => db;
File /app/routes.js:
import { Router } from 'express';
import { getDb } from './database.js';
import { nanoid } from 'nanoid';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import exifParser from 'exif-parser';
import sharp from 'sharp';

const router = Router();
const upload = multer({ dest: 'data/temp/' });

// --- Helper Functions ---
const getFullObjectDetails = async (table, id) => {
    console.log(`[API] Fetching full details for object '${id}' in table '${table}'`);
    const db = getDb();
    const object = await db.get(`SELECT * FROM ${table} WHERE id = ?`, id);
    if (!object) return null;

    object.key_values = await db.all('SELECT id, key, value FROM key_values WHERE object_id = ? ORDER BY id', id);

    // --- Start: Two-Level Link Fetching ---

    // Get Level 1 links
    const L1_links_raw = await db.all(`
        SELECT target_id as id, target_table as "table" FROM links WHERE source_id = ? AND source_table = ?
        UNION
        SELECT source_id as id, source_table as "table" FROM links WHERE target_id = ? AND target_table = ?
    `, id, table, id, table);

    let all_links_raw = [...L1_links_raw];

    // Get Level 2 links (links of level 1 links)
    if (L1_links_raw.length > 0) {
        // Note: SQLite tuple IN clause support `(col1, col2) IN ((?), (?))` is tricky with node-sqlite.
        // We will fetch them iteratively, which is safe and compatible.
        const L2_links_promises = L1_links_raw.map(l1_link =>
            db.all(`
                SELECT target_id as id, target_table as "table" FROM links WHERE source_id = ? AND source_table = ?
                UNION
                SELECT source_id as id, source_table as "table" FROM links WHERE target_id = ? AND target_table = ?
            `, l1_link.id, l1_link.table, l1_link.id, l1_link.table)
        );
        const L2_links_results = await Promise.all(L2_links_promises);
        all_links_raw.push(...L2_links_results.flat());
    }

    // De-duplicate and filter out the original object itself
    const uniqueLinks = new Map();
    all_links_raw.forEach(link => {
        if (link.id === id && link.table === table) return; // Exclude the main object
        uniqueLinks.set(`${link.table}:${link.id}`, link);
    });
    const linkedIds = Array.from(uniqueLinks.values());

    // --- End: Two-Level Link Fetching ---

    // Now fetch details for all unique links
    const tableQueries = {
        places: `SELECT id, title, 'places' as "table" FROM places WHERE id = ?`,
        people: `SELECT id, title, 'people' as "table" FROM people WHERE id = ?`,
        interactions: `SELECT id, title, 'interactions' as "table" FROM interactions WHERE id = ?`,
        custom_objects: `SELECT id, title, object_type, 'custom_objects' as "table" FROM custom_objects WHERE id = ?`,
        images: `SELECT id, title, 'images' as "table", file_path FROM images WHERE id = ?`,
        files: `SELECT id, title, 'files' as "table", file_path FROM files WHERE id = ?`,
        todos: `SELECT id, title, 'todos' as "table", status FROM todos WHERE id = ?`,
    };

    const linkedObjects = await Promise.all(
        linkedIds.map(link => {
            const query = tableQueries[link.table];
            return query ? db.get(query, link.id) : Promise.resolve(null);
        })
    );
    object.links = linkedObjects.filter(Boolean);
    object.table = table;
    return object;
};
const saveKeyValues = async (objectId, objectTable, keyValues) => {
    if (!keyValues) return;
    const db = getDb();
    const kvPairs = Object.entries(keyValues).filter(([k, v]) => k && v);
    for (const [key, value] of kvPairs) {
        await db.run('INSERT INTO key_values (object_id, object_table, key, value) VALUES (?, ?, ?, ?)', objectId, objectTable, key, value);
    }
};
const saveLinks = async (sourceId, sourceTable, links) => {
    if (!links || !Array.isArray(links) || links.length === 0) return;
    const db = getDb();
    for (const link of links) {
        if(!link) continue;
        const [targetTable, targetId] = link.split(':');
        if (!targetTable || !targetId || (sourceId === targetId && sourceTable === targetTable)) continue;
        console.log(`[Link] Linking ${sourceTable}:${sourceId} to ${targetTable}:${targetId}`);
        await db.run('INSERT OR IGNORE INTO links (source_id, source_table, target_id, target_table) VALUES (?, ?, ?, ?)', sourceId, sourceTable, targetId, targetTable);
    }
};

// --- GPS & HEIC Processing ---
const getDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

const processImageFile = async (file) => {
    console.log(`[Image Processing] Starting for: ${file.originalname}`);
    const inputPath = path.resolve(file.path);
    const inputBuffer = fs.readFileSync(inputPath);
    let gpsCoords = null;
    let fileDate = new Date();
    let finalFilename;
    let title = file.originalname;

    try {
        const jpegBuffer = await sharp(inputBuffer)
            .withMetadata()
            .jpeg({ quality: 90 })
            .toBuffer();
        console.log(`[Image Processing] Successfully converted '${file.originalname}' to JPEG buffer with Sharp.`);

        const parser = exifParser.create(jpegBuffer);
        const result = parser.parse();
        console.log('[Image Processing] EXIF data found in converted JPEG:', result.tags);

        if (result.tags && result.tags.DateTimeOriginal) {
            fileDate = new Date(result.tags.DateTimeOriginal * 1000);
            console.log(`[Image Processing] Parsed DateTimeOriginal: ${fileDate.toISOString()}`);
        } else if (result.tags && result.tags.CreateDate) {
            let dateStr = result.tags.CreateDate;
            let parsedDate;
            if (typeof dateStr === 'string') {
                const parts = dateStr.split(' ');
                if (parts.length > 0) parts[0] = parts[0].replace(/:/g, '-');
                dateStr = parts.join(' ');
                parsedDate = new Date(dateStr);
            } else if (typeof dateStr === 'number') {
                parsedDate = new Date(dateStr * 1000);
            }
            if (parsedDate && !isNaN(parsedDate)) {
                fileDate = parsedDate;
                console.log(`[Image Processing] Parsed CreateDate: ${fileDate.toISOString()}`);
            }
        } else {
            console.log('[Image Processing] No date tag found. Using current date.');
        }

        if (result.tags && result.tags.GPSLatitude && result.tags.GPSLongitude) {
            gpsCoords = { lat: result.tags.GPSLatitude, lng: result.tags.GPSLongitude };
            console.log('[Image Processing] Parsed GPS Coords:', gpsCoords);
        } else {
            console.log('[Image Processing] No GPS tags found.');
        }

        const dateString = fileDate.toISOString().slice(0, 10);
        const uniqueId = nanoid(6);
        const finalExtension = '.jpg';

        if (path.extname(title).toLowerCase() !== finalExtension) {
            title = `${path.parse(title).name}${finalExtension}`;
        }

        finalFilename = `${dateString}-${uniqueId}${finalExtension}`;
        const finalPath = path.resolve(`./data/images/${finalFilename}`);
        fs.writeFileSync(finalPath, jpegBuffer);
        console.log(`[Image Processing] Saved final file to: ${finalPath}`);
    } catch (err) {
        console.error(`[Image Processing] Error during Sharp/EXIF processing for ${file.originalname}:`, err.message);
        fs.unlinkSync(inputPath);
        return null;
    }

    fs.unlinkSync(inputPath);
    return { gpsCoords, finalFilename, title };
};

const linkGpsData = async (imageId, gpsCoords, imageTitle) => {
    if (!gpsCoords) return null;
    const { lat, lng } = gpsCoords;
    const db = getDb();
    const allPlaces = await db.all('SELECT id, lat, lng FROM places');
    const closestPlace = allPlaces.reduce((closest, place) => {
        const distance = getDistance(lat, lng, place.lat, place.lng);
        if (distance < closest.minDistance) return { place, minDistance: distance };
        return closest;
    }, { place: null, minDistance: Infinity });

    const toleranceKm = 0.05; // 50 meters
    if (closestPlace.place && closestPlace.minDistance < toleranceKm) {
        await saveLinks(imageId, 'images', [`places:${closestPlace.place.id}`]);
        console.log(`[GPS Linking] Linked image ${imageId} to existing place ${closestPlace.place.id}`);
        return null;
    } else {
        const placeId = nanoid();
        await db.run('INSERT INTO places (id, title, lat, lng) VALUES (?, ?, ?, ?)', placeId, imageTitle, lat, lng);
        await saveLinks(imageId, 'images', [`places:${placeId}`]);
        const newPlace = await db.get('SELECT * FROM places WHERE id = ?', placeId);
        newPlace.table = 'places';
        console.log(`[GPS Linking] Created new place ${placeId} for image ${imageId}`);
        return newPlace;
    }
};

// --- API Routes ---
router.get('/recent', async (req, res) => {
    try {
        const limit = parseInt(req.query.limit) || 20;
        const offset = parseInt(req.query.offset) || 0;
        const db = getDb();

        const results = await db.all(`
            SELECT id, title, "table", created_at, object_type, file_path, status
            FROM (
                SELECT
                    *,
                    CASE WHEN "table" = 'todos' AND status = 0 THEN 0 ELSE 1 END as sort1,
                    CASE WHEN "table" = 'todos' AND status = 0 THEN created_at END as sort2,
                    CASE WHEN "table" != 'todos' OR status = 1 THEN created_at END as sort3
                FROM (
                    SELECT id, title, 'places' as "table", created_at, null as object_type, null as file_path, -1 as status FROM places
                    UNION ALL SELECT id, title, 'people' as "table", created_at, null as object_type, null as file_path, -1 as status FROM people
                    UNION ALL SELECT id, title, 'interactions' as "table", created_at, null as object_type, null as file_path, -1 as status FROM interactions
                    UNION ALL SELECT id, title, 'custom_objects' as "table", created_at, object_type, null as file_path, -1 as status FROM custom_objects
                    UNION ALL SELECT id, title, 'images' as "table", created_at, null as object_type, file_path, -1 as status FROM images
                    UNION ALL SELECT id, title, 'files' as "table", created_at, null as object_type, file_path, -1 as status FROM files
                    UNION ALL SELECT id, title, 'todos' as "table", created_at, null as object_type, null as file_path, status FROM todos
                ) as union_sub
            ) as sort_sub
            ORDER BY
                sort1 ASC,
                sort2 ASC,
                sort3 DESC
            LIMIT ? OFFSET ?
        `, limit, offset);

        res.json(results);
    } catch (e) {
        console.error('[API Error] /recent:', e);
        res.status(500).json({ error: e.message });
    }
});

router.get('/bootstrap', async (req, res) => {
    try {
        const db = getDb();
        const places = await db.all('SELECT id, title, lat, lng FROM places');
        const objectCountResult = await db.get(`SELECT
            (SELECT COUNT(id) FROM places) +
            (SELECT COUNT(id) FROM people) +
            (SELECT COUNT(id) FROM interactions) +
            (SELECT COUNT(id) FROM custom_objects) +
            (SELECT COUNT(id) FROM images) +
            (SELECT COUNT(id) FROM files) +
            (SELECT COUNT(id) FROM todos) as count`);
        res.json({ places, hasObjects: objectCountResult.count > 0 });
    } catch (e) {
        console.error('[API Error] /bootstrap:', e);
        res.status(500).json({ error: e.message });
    }
});

router.get('/custom-object-types', async (req, res) => {
    try {
        const db = getDb();
        const types = await db.all('SELECT DISTINCT object_type FROM custom_objects ORDER BY object_type');
        res.json(types.map(t => t.object_type));
    } catch (e) {
        console.error('[API Error] /custom-object-types:', e);
        res.status(500).json({ error: e.message });
    }
});

router.get('/objects/:table', async (req, res) => {
    try {
        const { table } = req.params;
        const limit = parseInt(req.query.limit) || 20;
        const offset = parseInt(req.query.offset) || 0;
        const db = getDb();
        let items;

        if (table === 'todos') {
            items = await db.all(`
                SELECT id, title, created_at, status FROM todos
                ORDER BY status ASC,
                         CASE WHEN status = 0 THEN created_at END ASC,
                         CASE WHEN status = 1 THEN created_at END DESC
                LIMIT ? OFFSET ?`, limit, offset);
        } else if (table === 'custom_objects') {
            const types = req.query.types ? JSON.parse(req.query.types) : [];
            let query = `SELECT id, title, created_at, object_type FROM custom_objects`;
            const params = [];

            if (types.length > 0) {
                query += ` WHERE object_type IN (${types.map(() => '?').join(',')})`;
                params.push(...types);
            }

            query += ` ORDER BY created_at DESC LIMIT ? OFFSET ?`;
            params.push(limit, offset);
            items = await db.all(query, ...params);
        } else {
            const columnsToSelect = ['id', 'title', 'created_at'];
            if (table === 'images' || table === 'files') columnsToSelect.push('file_path');
            items = await db.all(`SELECT ${columnsToSelect.join(', ')} FROM ${table} ORDER BY created_at DESC LIMIT ? OFFSET ?`, limit, offset);
        }

        // Add table property to all items before sending
        items.forEach(item => item.table = table);

        res.json(items);
    } catch (e) {
        console.error(`[API Error] /objects/${req.params.table}:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.get('/object/:table/:id', async (req, res) => {
    try {
        const { table, id } = req.params;
        const object = await getFullObjectDetails(table, id);
        if (!object) return res.status(404).json({ error: 'Object not found' });
        res.json(object);
    } catch (e) {
        console.error(`[API Error] /object/${req.params.table}/${req.params.id}:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.get('/search', async (req, res) => {
    try {
        const { term } = req.query;
        const limit = parseInt(req.query.limit) || 25;
        if (!term || term.length < 3) return res.json([]);
        console.log(`[API] Searching for term: "${term}" with limit ${limit}`);
        const query = `%${term}%`;
        const db = getDb();
        const results = await db.all(`
            SELECT id, title, 'places' as "table" FROM places WHERE title LIKE ?
            UNION ALL SELECT id, title, 'people' as "table" FROM people WHERE title LIKE ?
            UNION ALL SELECT id, title, 'interactions' as "table" FROM interactions WHERE title LIKE ?
            UNION ALL SELECT id, title, 'custom_objects' as "table" FROM custom_objects WHERE title LIKE ?
            UNION ALL SELECT id, title, 'images' as "table" FROM images WHERE title LIKE ?
            UNION ALL SELECT id, title, 'files' as "table" FROM files WHERE title LIKE ?
            UNION ALL SELECT id, title, 'todos' as "table" FROM todos WHERE title LIKE ?
            ORDER BY title LIMIT ?
        `, query, query, query, query, query, query, query, limit);
        res.json(results);
    } catch (e) {
        console.error('[API Error] /search:', e);
        res.status(500).json({ error: e.message });
    }
});

const createGenericObject = async (table, req, res) => {
    try {
        console.log(`[API] Creating object in table '${table}' with data:`, req.body);
        let { links, key_values, ...data } = req.body;
        if (typeof links === 'string') {
            try { links = JSON.parse(links); } catch(e) { links = []; }
        }

        const id = nanoid();
        const db = getDb();
        const columnData = { ...data };

        if (table === 'custom_objects') {
            columnData.object_type = data.object_type.toLowerCase().replace(/\s+/g, '-');
        }

        const columns = Object.keys(columnData);
        const values = Object.values(columnData);

        await db.run(`INSERT INTO ${table} (id, ${columns.join(',')}) VALUES (?, ${columns.map(() => '?').join(',')})`, id, ...values);
        await saveKeyValues(id, table, key_values);
        await saveLinks(id, table, links);

        console.log(`[API] Successfully created object '${id}' in table '${table}'`);
        res.status(201).json(await getFullObjectDetails(table, id));
    } catch (e) {
        console.error(`[API Error] Error creating generic object in table ${table}:`, e);
        res.status(500).json({ error: e.message });
    }
};

router.post('/object/place', (req, res) => createGenericObject('places', req, res));
router.post('/object/person', (req, res) => createGenericObject('people', req, res));
router.post('/object/interaction', (req, res) => createGenericObject('interactions', req, res));
router.post('/object/custom_object', (req, res) => createGenericObject('custom_objects', req, res));
router.post('/object/todo', (req, res) => createGenericObject('todos', req, res));

router.post('/object/image', upload.array('files'), async (req, res) => {
    try {
        console.log(`[API] Creating image object(s)`);
        const links = req.body.links ? JSON.parse(req.body.links) : [];
        const db = getDb();
        const createdObjects = [];
        for (const file of req.files) {
            const processed = await processImageFile(file);
            if (!processed) continue;

            const { gpsCoords, finalFilename, title } = processed;
            const id = nanoid();

            await db.run('INSERT INTO images (id, title, file_path) VALUES (?, ?, ?)', id, title, `/images/${finalFilename}`);
            await saveLinks(id, 'images', links);

            if (gpsCoords) {
                const newPlace = await linkGpsData(id, gpsCoords, title);
                if (newPlace) {
                    createdObjects.push(newPlace);
                }
            }
            const imageDetails = await getFullObjectDetails('images', id);
            createdObjects.push(imageDetails);
        }
        console.log(`[API] Successfully created ${createdObjects.length} image-related objects.`);
        res.status(201).json(createdObjects);
    } catch (e) {
        console.error(`[API Error] creating image object:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.post('/object/other_file', upload.array('files'), async (req, res) => {
    try {
        console.log(`[API] Creating file object(s)`);
        const links = req.body.links ? JSON.parse(req.body.links) : [];
        const db = getDb();
        const createdFiles = [];
        const targetDir = path.resolve('./data/files');
        if (!fs.existsSync(targetDir)) fs.mkdirSync(targetDir, { recursive: true });

        for (const file of req.files) {
            const tempPath = file.path;
            const finalFilename = `${new Date().toISOString().slice(0, 10)}-${nanoid(6)}${path.extname(file.originalname)}`;
            const finalPath = path.join(targetDir, finalFilename);
            fs.renameSync(tempPath, finalPath);

            const id = nanoid();
            await db.run('INSERT INTO files (id, title, file_path) VALUES (?, ?, ?)', id, file.originalname, `/files/${finalFilename}`);
            await saveLinks(id, 'files', links);
            createdFiles.push(await getFullObjectDetails('files', id));
        }
        console.log(`[API] Successfully created ${createdFiles.length} file objects.`);
        res.status(201).json(createdFiles);
    } catch (e) {
        console.error(`[API Error] creating file object:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.post('/object/:table/:id/kv', async (req, res) => {
    try {
        const { table, id } = req.params;
        const { key, value } = req.body;
        console.log(`[API] Adding KV pair to ${table}:${id} -> ${key}:${value}`);
        const db = getDb();
        const result = await db.run('INSERT INTO key_values (object_id, object_table, key, value) VALUES (?, ?, ?, ?)', id, table, key, value);
        res.status(201).json({ id: result.lastID, key, value });
    } catch (e) {
        console.error(`[API Error] adding KV pair:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.post('/link', async (req, res) => {
    try {
        const { source_id, source_table, target_id, target_table } = req.body;
        await saveLinks(source_id, source_table, [`${target_table}:${target_id}`]);
        res.status(201).json({ success: true });
    } catch (e) {
        console.error(`[API Error] creating link:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.patch('/object/:table/:id', async (req, res) => {
    try {
        const { table, id } = req.params;
        const { field, value } = req.body;
        console.log(`[API] Patching ${table}:${id} with field '${field}' and value '${value}'`);
        const db = getDb();

        if (field === 'title') {
            if (!value) {
                return res.status(400).json({ error: `Title field cannot be empty.` });
            }
            await db.run(`UPDATE ${table} SET title = ? WHERE id = ?`, value, id);
            console.log(`[API] Successfully updated title for ${table}:${id}`);
            return res.status(200).json({ success: true, newValue: value });

        } else if (field === 'status' && table === 'todos') {
            const newStatus = Number(value);
            if (newStatus === undefined || newStatus === null || ![0, 1].includes(newStatus)) {
                return res.status(400).json({ error: 'Invalid value for status' });
            }
            await db.run(`UPDATE todos SET status = ? WHERE id = ?`, newStatus, id);
            console.log(`[API] Successfully updated status for todo:${id}`);
            return res.status(200).json({ success: true, newValue: newStatus });

        } else {
            return res.status(400).json({ error: 'Invalid field for patching' });
        }
    } catch (e) {
        console.error(`[API Error] patching ${req.params.table}:${req.params.id}:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.patch('/kv/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { key, value } = req.body;
        console.log(`[API] Patching KV ${id} with ${key}:${value}`);
        const db = getDb();
        await db.run('UPDATE key_values SET key = ?, value = ? WHERE id = ?', key, value, id);
        res.status(200).json({ success: true });
    } catch (e) {
        console.error(`[API Error] patching KV ${req.params.id}:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.delete('/kv/:id', async (req, res) => {
    try {
        const { id } = req.params;
        console.log(`[API] Deleting KV ${id}`);
        const db = getDb();
        await db.run('DELETE FROM key_values WHERE id = ?', id);
        res.status(200).json({ success: true });
    } catch (e) {
        console.error(`[API Error] deleting KV ${req.params.id}:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.post('/unlink', async (req, res) => {
    try {
        const { source_id, source_table, target_id, target_table } = req.body;
        console.log(`[API] Unlinking ${source_table}:${source_id} from ${target_table}:${target_id}`);
        const db = getDb();
        await db.run(`DELETE FROM links WHERE (source_id = ? AND source_table = ? AND target_id = ? AND target_table = ?) OR (source_id = ? AND source_table = ? AND target_id = ? AND target_table = ?)`, source_id, source_table, target_id, target_table, target_id, target_table, source_id, source_table);
        res.status(200).json({ success: true });
    } catch (e) {
        console.error(`[API Error] unlinking objects:`, e);
        res.status(500).json({ error: e.message });
    }
});

router.delete('/object/:table/:id', async (req, res) => {
    try {
        const { table, id } = req.params;
        console.log(`[API] Deleting object ${table}:${id}`);
        const db = getDb();
        if (table === 'images' || table === 'files') {
            const fileObject = await db.get(`SELECT file_path FROM ${table} WHERE id = ?`, id);
            if (fileObject) {
                const filePath = path.resolve(`./data${fileObject.file_path}`);
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                    console.log(`[File System] Deleted file: ${filePath}`);
                }
            }
        }

        await db.run(`DELETE FROM ${table} WHERE id = ?`, id);
        await db.run('DELETE FROM key_values WHERE object_id = ?', id);
        await db.run('DELETE FROM links WHERE source_id = ? OR target_id = ?', id, id);
        console.log(`[API] Successfully deleted object ${table}:${id} and associated data.`);
        res.status(200).json({ success: true });
    } catch (e) {
        console.error(`[API Error] deleting object ${req.params.table}:${req.params.id}:`, e);
        res.status(500).json({ error: e.message });
    }
});

export default router;
File /public/index.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashy - Manage your Life</title>
    <link rel="stylesheet" href="/leaflet/leaflet.css" />
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://kit.fontawesome.com/5cda090907.js" crossorigin="anonymous"></script>
</head>
<body>
<div class="container">
    <div id="map"></div>
    <div id="app-panel">
        <div class="app-panel-header">
            <h1 id="app-title">Dashy</h1>
            <button id="add-new-button" class="button button-primary hidden" title="Add New Item"><i class="fas fa-plus"></i> <span>Add New</span></button>
        </div>
        <div id="app-panel-content">
        </div>
        <footer id="bottom-nav">
            <button class="nav-btn" data-type="dashboard" title="Dashboard"><i class="fas fa-home"></i></button>
            <button class="nav-btn" data-type="places" title="Places"><i class="fas fa-map-marker-alt"></i></button>
            <button class="nav-btn" data-type="people" title="People"><i class="fas fa-user"></i></button>
            <button class="nav-btn" data-type="todos" title="To-Dos"><i class="fas fa-check-square"></i></button>
            <button class="nav-btn" data-type="interactions" title="Interactions"><i class="fas fa-shuffle"></i></button>
            <button class="nav-btn" data-type="custom_objects" title="Custom Objects"><i class="fas fa-tag"></i></button>
            <button class="nav-btn" data-type="images" title="Images"><i class="fas fa-image"></i></button>
            <button class="nav-btn" data-type="files" title="Files"><i class="fas fa-file-alt"></i></button>
        </footer>
    </div>
</div>
<div id="modal-overlay" class="hidden">
    <div id="modal-content"></div>
</div>
<script type="importmap">
    {
        "imports": {
            "leaflet": "/leaflet/leaflet.js"
        }
    }
</script>
<script type="module" src="/js/main.js"></script>
</body>
</html>
File /public/css/style.css:
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
    --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    --bg-primary: #111317;
    --bg-secondary: #1A1D23;
    --bg-tertiary: #272A31;
    --border-color: #363A43;
    --text-primary: #E5E7EB;
    --text-secondary: #9CA3AF;
    --text-tertiary: #6B7280;
    --accent-primary: #38BDF8; /* Light Blue */
    --accent-secondary: #0E7490; /* Darker Blue */
    --danger: #F43F5E;
    --success: #34D399;
    --warning: #FBBF24;
    --radius-md: 0.5rem;
    --radius-lg: 0.75rem;
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.1);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.15), 0 2px 4px -2px rgb(0 0 0 / 0.15);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.2);
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 16px; }
body { height: 100vh; width: 100vw; overflow: hidden; font-family: var(--font-sans); background-color: var(--bg-primary); color: var(--text-primary); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
.container { display: flex; height: 100%; width: 100%; }

/* --- Map --- */
#map { width: 50%; height: 100%; background-color: var(--bg-secondary); z-index: 1; border-right: 1px solid var(--border-color); }
.leaflet-tile-pane { filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7); }
.leaflet-marker-icon { transition: transform 0.2s ease-out, filter 0.2s ease-out; }
.leaflet-marker-icon.highlighted { filter: drop-shadow(0 0 3px #fff) drop-shadow(0 0 12px var(--success)) saturate(3); }
.leaflet-marker-temp { filter: hue-rotate(300deg) saturate(5); }

/* --- Main Panel --- */
#app-panel { width: 50%; height: 100%; display: flex; flex-direction: column; background-color: var(--bg-primary); }
.app-panel-header { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1.5rem; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); flex-shrink: 0; box-shadow: var(--shadow-md); z-index: 10; }
.app-panel-header h1 { font-size: 1.25rem; color: var(--text-primary); cursor: pointer; font-weight: 600; }
.app-panel-header h1:hover { color: var(--accent-primary); }
#app-panel-content { flex-grow: 1; overflow-y: auto; padding: 1rem 2rem 2rem 2rem; }
.welcome-message { text-align: center; color: var(--text-secondary); padding-top: 5rem; }
.welcome-message i { font-size: 4rem; margin-bottom: 1rem; color: var(--bg-tertiary); }
.welcome-message p { max-width: 40ch; margin: 0 auto; line-height: 1.6; }

/* --- Buttons & Inputs --- */
.hidden { display: none !important; }
.button { background-color: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 0.6rem 1.2rem; border-radius: var(--radius-md); cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; text-decoration: none; }
.button:hover { background-color: var(--border-color); color: #fff; transform: translateY(-1px); }
.button.button-primary { background-color: var(--accent-secondary); border-color: var(--accent-secondary); color: #fff; }
.button.button-primary:hover { background-color: var(--accent-primary); border-color: var(--accent-primary); }
.button-danger { background-color: transparent; border-color: var(--danger); color: var(--danger); }
.button-danger:hover { background-color: var(--danger); color: #fff; }
.action-button { background: none; border: none; color: var(--text-tertiary); cursor: pointer; padding: 0.4rem; border-radius: 50%; width: 32px; height: 32px; display: inline-flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
.action-button:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
.todo-status-button {
    font-weight: 600;
    border: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
}
.todo-status-button.incomplete {
    background-color: var(--danger);
    color: #fff;
}
.todo-status-button.complete {
    background-color: var(--success);
    color: var(--bg-primary);
}

input[type="text"], input[type="date"], input[type="number"], textarea, select { width: 100%; padding: 0.75rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--radius-md); color: var(--text-primary); font-size: 1rem; transition: border-color 0.2s, box-shadow 0.2s; }
input:focus, textarea:focus, select:focus { border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.3); outline: none; }
.form-group { margin-bottom: 1.25rem; }
.form-group label { font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; display: block; font-size: 0.875rem; }
.inline-edit-input { padding: 0.1rem 0.5rem; margin-left: -0.5rem; font-size: 2.25rem; font-weight: 700; width: 100%; }

/* --- Object & List Views --- */
.list-view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 1rem;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    border-bottom: none;
}
.list-view-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    line-height: 1.2;
    flex-grow: 1;
}
.object-view-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 1rem; margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); }
.object-view-header h2 { font-size: 1.75rem; font-weight: 700; display: flex; align-items: center; gap: 0.75rem; line-height: 1.2; flex-grow: 1; }
.object-view-header h2 .editable-title { cursor: pointer; transition: color 0.2s; }
.object-view-header h2 .editable-title:hover { color: var(--accent-primary); }
.object-view-header h2.completed .editable-title { text-decoration: line-through; color: var(--text-tertiary); }
.object-view-header h2 .object-type-display { display: block; font-size: 0.875rem; color: var(--text-secondary); font-weight: 500; margin-top: 0.25rem; }

.image-preview {
    display: block;
    max-width: 100%;
    max-height: 65vh;
    border-radius: var(--radius-md);
    margin: 0 auto 1.5rem auto;
    background-color: var(--bg-primary);
}

.detail-item { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; font-size: 1rem; }
.detail-item i { color: var(--accent-primary); width: 20px; text-align: center; }
.mood-bar { flex-grow: 1; height: 6px; background: var(--bg-tertiary); border-radius: 3px; position: relative; }
.mood-bar .thumb { width: 100%; height: 100%; background: linear-gradient(to right, var(--danger), var(--warning), var(--success)); border-radius: 3px; transform-origin: left; }

.section { margin-bottom: 2.5rem; }
.section-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem; }
.section-header h3 { font-size: 0.875rem; font-weight: 600; display: flex; align-items: center; gap: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; }

/* Lists (Links, KV, Items) */
.kv-list { list-style: none; }
.kv-list li { display: grid; grid-template-columns: 1fr 2fr auto; align-items: center; gap: 1rem; padding: 0.5rem 0.75rem; border-radius: var(--radius-md); transition: background-color 0.2s; }
.kv-list li:hover { background-color: var(--bg-secondary); }
.kv-list .key { font-weight: 500; color: var(--text-secondary); }
.kv-list .value { color: var(--text-primary); }
.kv-list .actions { display: flex; gap: 0.25rem; visibility: hidden; }
.kv-list li:hover .actions, .kv-list li.kv-edit-mode .actions { visibility: visible; }
.kv-list input { background-color: var(--bg-primary); }

.items-list-view { list-style: none; }
.links-list { list-style: none; padding: 0; }
.links-list li, .items-list-view li { background-color: var(--bg-secondary); padding: 0.6rem 1rem; margin-bottom: 0.5rem; border-radius: var(--radius-md); display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: all 0.2s ease; border: 1px solid var(--border-color); position: relative; }
.links-list li:hover, .items-list-view li:hover {
    border-color: var(--accent-primary);
    box-shadow: var(--shadow-md);
}
.link-title, .item-title { display: flex; align-items: center; gap: 0.75rem; font-weight: 500; flex-grow: 1; min-width: 0; }
.link-title span, .item-title span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.item-title.completed { text-decoration: line-through; color: var(--text-tertiary); }
.item-type-label { font-size: 0.7rem; font-weight: 600; text-transform: uppercase; background-color: var(--bg-tertiary); color: var(--text-secondary); padding: 0.1rem 0.4rem; border-radius: 4px; border: 1px solid var(--border-color); }
.items-list-view .item-meta { display: flex; align-items: center; gap: 0.75rem; }

/* Dashboard Search Box */
.dashboard-search-container {
    position: relative;
    max-width: 350px;
    width: 100%;
}
.dashboard-search-container input {
    width: 100%;
}
.dashboard-search-container .search-results-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    z-index: 20;
    margin-top: 0.25rem;
    max-height: 400px;
}

/* --- Image Grids (List View & Object View) --- */
.image-grid, .links-list.image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 1rem; margin-top: 1.5rem; list-style: none; padding: 0; }
.image-grid .list-item, .links-list.image-grid .link-item { position: relative; padding: 0; background: none; border: none; flex-direction: column; height: auto; aspect-ratio: 1 / 1; box-shadow: var(--shadow-md); cursor: pointer; }
.image-grid .list-item:hover, .links-list.image-grid .link-item:hover { transform: scale(1.05); z-index: 5; }
.image-grid img, .links-list.image-grid img { width: 100%; height: 100%; object-fit: cover; border-radius: var(--radius-md); }
.links-list.image-grid .link-item .unlink-btn { position: absolute; top: 0.25rem; right: 0.25rem; z-index: 2; background-color: rgba(17, 19, 23, 0.7); color: white; visibility: hidden; opacity: 0; transition: visibility 0.2s, opacity 0.2s; }
.links-list.image-grid .link-item:hover .unlink-btn { visibility: visible; opacity: 1; }

/* Bottom Nav */
#bottom-nav { flex-shrink: 0; display: flex; justify-content: space-around; background-color: var(--bg-secondary); border-top: 1px solid var(--border-color); }
.nav-btn { background: none; border: none; color: var(--text-secondary); font-size: 1.25rem; padding: 0.75rem; cursor: pointer; transition: all 0.2s ease; flex-grow: 1; position: relative; }
.nav-btn.active, .nav-btn:hover { color: var(--accent-primary); }

/* Link Form & Custom Type Dropdown */
.add-link-form { margin-top: 1.5rem; }
.form-container .add-link-form { margin-top: 0.5rem; }
.form-container .form-group > label:not([for]) { margin-bottom: 0; }
.custom-type-search-container { position: relative; }

.link-creation-options { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin: 1rem 0; }
.link-creation-options .button {
    font-size: 1rem;
    padding: 0.6rem;
    border-radius: var(--radius-md);
    background-color: var(--bg-tertiary);
    width: 40px;
    height: 40px;
}
.link-creation-options .button:hover { background-color: var(--border-color); }
.search-results-list { list-style: none; max-height: 150px; overflow-y: auto; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-md); margin-top: 0.5rem; }
.search-results-list.custom-type-results { position: absolute; width: 100%; z-index: 10; display: none; margin-top: 0.1rem; }
.search-results-list li { padding: 0.75rem; cursor: pointer; display: flex; align-items: center; gap: 0.75rem; }
.search-results-list li:hover { background-color: var(--accent-secondary); }
.linked-items-preview { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 1rem; }
.linked-item-tag { background-color: var(--bg-tertiary); padding: 0.3rem 0.6rem; border-radius: var(--radius-md); font-size: 0.875rem; display: flex; align-items: center; gap: 0.5rem; }

/* Custom Object Filter Tags */
.filter-tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    padding-bottom: 0;
    border-bottom: none;
}
.filter-tag {
    background-color: var(--bg-tertiary);
    color: var(--text-secondary);
    border: 1px solid var(--border-color);
    padding: 0.25rem 0.75rem;
    border-radius: var(--radius-md);
    font-size: 0.8rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}
.filter-tag:hover {
    background-color: var(--border-color);
    color: var(--text-primary);
}
.filter-tag.active {
    background-color: var(--accent-primary);
    border-color: var(--accent-primary);
    color: var(--bg-primary);
}


/* Custom File Input */
.custom-file-input-container { margin-top: 0.5rem; }
.custom-file-input { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
.custom-file-input + label.button { display: inline-flex; margin-bottom: 0.5rem; }
.file-list { list-style: none; padding-left: 0; margin-top: 0.5rem; }
.file-list li { background-color: var(--bg-secondary); padding: 0.5rem 0.75rem; border-radius: var(--radius-md); margin-bottom: 0.25rem; font-size: 0.875rem; color: var(--text-secondary); word-break: break-all; }

/* Form Container */
.form-container { max-width: 600px; margin: 0 auto; }
.form-container h2 { margin-bottom: 2rem; font-size: 1.75rem; font-weight: 700; display: flex; align-items: center; gap: 0.75rem; }

/* Modal (for On-the-fly creation) */
#modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: transparent;
    z-index: 1000;
    display: flex;
    align-items: stretch;
    justify-content: flex-end;
    pointer-events: none;
}
#modal-overlay.hidden {
    display: none;
}
#modal-content {
    background-color: var(--bg-primary);
    width: 50%;
    height: 100%;
    box-shadow: var(--shadow-lg);
    display: flex;
    flex-direction: column;
    pointer-events: auto;
}
.modal-header { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1.5rem; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
.modal-header h2 { font-size: 1.25rem; font-weight: 600; }
.modal-body { padding: 2rem; overflow-y: auto; flex-grow: 1; }

/* Todo specific styles */
.todo-status-toggle, .todo-list-status { display: flex; align-items: center; gap: 0.5rem; }
.todo-list-status { padding-right: 1rem; }
.list-item.todo-item { gap: 0; }
.completed-todos-container.hidden { display: none; }
.show-completed-todos-btn { margin-top: 1rem; }
File /public/js/api.js:
const handleResponse = async (response) => {
    if (!response.ok) {
        const error = await response.json().catch(() => ({ error: 'An unknown error occurred' }));
        throw new Error(error.error || `HTTP error! status: ${response.status}`);
    }
    return response.json();
};

export async function post(path, data) {
    return fetch(`/api${path}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
    }).then(handleResponse);
}

export async function patch(path, data) {
    return fetch(`/api${path}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
    }).then(handleResponse);
}

export async function del(path) {
    return fetch(`/api${path}`, {
        method: 'DELETE'
    }).then(handleResponse);
}

export async function getBootstrapData() {
    return fetch('/api/bootstrap').then(handleResponse);
}

export async function getObject(table, id) {
    return fetch(`/api/object/${table}/${id}`).then(handleResponse);
}

export async function getObjectsList(table, { limit = 20, offset = 0, filters = {} } = {}) {
    let url;
    if (table === 'recent') {
        url = `/api/recent?limit=${limit}&offset=${offset}`;
    } else {
        url = `/api/objects/${table}?limit=${limit}&offset=${offset}`;
        if (filters.types && filters.types.length > 0) {
            url += `&types=${encodeURIComponent(JSON.stringify(filters.types))}`;
        }
    }
    return fetch(url).then(handleResponse);
}

export async function getCustomObjectTypes() {
    return fetch('/api/custom-object-types').then(handleResponse);
}

export async function createObject(type, formData) {
    let body;
    let headers = {};
    if (['image', 'other_file'].includes(type)) {
        body = formData; // FormData sets its own content-type
    } else {
        const data = Object.fromEntries(formData.entries());

        // Handle multi-key for key_values
        const kvKeys = formData.getAll('kv_key');
        const kvValues = formData.getAll('kv_value');
        if (kvKeys.length > 0) {
            data.key_values = {};
            kvKeys.forEach((key, index) => {
                if (key) data.key_values[key] = kvValues[index];
            });
            // FIX: Remove raw kv fields to prevent backend error
            delete data.kv_key;
            delete data.kv_value;
        }

        body = JSON.stringify(data);
        headers['Content-Type'] = 'application/json';
    }
    return fetch(`/api/object/${type}`, { method: 'POST', headers, body }).then(handleResponse);
}

export async function searchObjects(term, limit = 10) {
    if (term.length < 2) return Promise.resolve([]);
    return fetch(`/api/search?term=${encodeURIComponent(term)}&limit=${limit}`).then(handleResponse);
}

export async function updateObject(table, id, field, value) {
    return patch(`/object/${table}/${id}`, { field, value });
}

export async function unlinkObjects(source, target) {
    return post('/unlink', {
        source_id: source.id,
        source_table: source.table,
        target_id: target.id,
        target_table: target.table,
    });
}

export async function deleteObject(table, id) {
    return del(`/object/${table}/${id}`);
}
File /public/js/main.js:
import { Map, TileLayer, Marker, Icon, DomEvent } from 'leaflet';
import * as api from './api.js';
import { initializeEventListeners } from './ui/events.js';
import { renderObject, renderDashboardView, renderWelcomeMessage } from './ui/main_view.js';
import { highlightMarker, clearHighlight } from './ui/helpers.js';

const appState = {
    map: null,
    markers: {},
    tempMarker: null,
    isModalOpen: false,
    currentView: null
};

// --- Map Logic ---
function initMap() {
    appState.map = new Map('map').setView([45.4642, 9.1900], 7);
    new TileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(appState.map);
    appState.map.on('click', handleMapClick);
}

function handleMapClick(e) {
    const isPlaceFormOpenInMain = window.dashy.appState.currentView?.type === 'form' && window.dashy.appState.currentView?.formType === 'place';
    const isPlaceFormOpenInModal = window.dashy.appState.isModalOpen && document.querySelector('#on-the-fly-add-form[data-type="place"]');

    if (isPlaceFormOpenInMain || isPlaceFormOpenInModal) {
        updateTempMarker(e.latlng);
        const event = new CustomEvent('map-clicked-for-form', { detail: e.latlng });
        window.dispatchEvent(event);
    } else {
        removeTempMarker();
    }
}

function updateTempMarker(latlng) {
    if (appState.tempMarker) {
        appState.tempMarker.setLatLng(latlng);
    } else {
        const tempIcon = new Icon({
            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
            className: 'leaflet-marker-temp'
        });
        appState.tempMarker = new Marker(latlng, { icon: tempIcon, zIndexOffset: 1000 }).addTo(appState.map);
    }
    appState.map.panTo(latlng);
}

export function removeTempMarker() {
    if (appState.tempMarker) {
        appState.map.removeLayer(appState.tempMarker);
        appState.tempMarker = null;
    }
}

// --- Data & Marker Management ---
async function bootstrapApp() {
    try {
        const data = await api.getBootstrapData();
        data.places.forEach(place => addMarkerToMap(place));
        if (data.hasObjects) {
            renderDashboardView();
        } else {
            renderWelcomeMessage();
        }
    } catch (error) {
        console.error("Could not bootstrap the app:", error);
        renderWelcomeMessage();
    }
}

function addMarkerToMap(place, shouldFlyTo = false) {
    if (appState.markers[place.id]) {
        appState.markers[place.id].setLatLng([place.lat, place.lng]);
    } else {
        const marker = new Marker([place.lat, place.lng]).addTo(appState.map);
        marker.on('click', (e) => {
            DomEvent.stopPropagation(e);
            clearHighlight();
            removeTempMarker();
            highlightMarker(marker);
            renderObject('places', place.id);
        });
        appState.markers[place.id] = marker;
    }
    if (shouldFlyTo) appState.map.flyTo([place.lat, place.lng], 15);
}

function removeMarkerFromMap(placeId) {
    if (appState.markers[placeId]) {
        appState.map.removeLayer(appState.markers[placeId]);
        delete appState.markers[placeId];
    }
}

// --- App Start ---
document.addEventListener('DOMContentLoaded', () => {
    initMap();
    initializeEventListeners();
    bootstrapApp();
    window.dashy = {
        appState,
        api,
        addMarkerToMap,
        removeMarkerFromMap,
        removeTempMarker,
        renderObject,
        renderDashboardView
    };
    document.getElementById('app-title').addEventListener('click', renderDashboardView);
    document.querySelector('.nav-btn[data-type="dashboard"]').classList.add('active');
});
File /public/js/ui/events.js:
import * as api from '../api.js';
import { contentPanel, debounce, getIconForTable, closeModal, formatObjectType } from './helpers.js';
import { renderAddForm, addLinkToForm, getSelectedLinks, renderOnTheFlyForm } from './forms.js';
import { renderObject, renderListView, loadMoreItems, renderDashboardView, loadFilteredItems, toggleCustomObjectFilter } from './main_view.js';

export function initializeEventListeners() {
    document.body.addEventListener('click', handleGlobalClick);
    document.body.addEventListener('submit', handleGlobalSubmit);
    document.body.addEventListener('change', handleGlobalChange);
    document.body.addEventListener('focusin', handleFocusIn); // For custom dropdown

    contentPanel.addEventListener('input', debounce(handleContentPanelInput, 300));
    contentPanel.addEventListener('keydown', handleKeyDown);
    contentPanel.addEventListener('focusout', handleFocusOut);
    contentPanel.addEventListener('scroll', handleInfiniteScroll);

    window.addEventListener('map-clicked-for-form', handleMapClickForForm);
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && window.dashy.appState.isModalOpen) {
            closeModal();
        }
    });
}

async function handleGlobalClick(e) {
    const target = e.target;

    // --- Actions that can happen anywhere (main panel or modal) ---
    if (target.closest('.add-kv-button')) {
        addKeyValueRow(target);
        return;
    }
    if (target.closest('.edit-kv-button')) {
        editKeyValueRow(target.closest('li'));
        return;
    }
    if (target.closest('.save-kv-button')) {
        await saveKeyValueRow(target.closest('li'));
        return;
    }
    if (target.closest('.delete-kv-button')) {
        await deleteKeyValueRow(target.closest('li'));
        return;
    }
    if (target.closest('.todo-status-button')) {
        const button = target.closest('.todo-status-button');
        const id = button.dataset.id;
        const currentStatus = parseInt(button.dataset.currentStatus, 10);
        const newStatus = currentStatus === 1 ? 0 : 1;
        await api.updateObject('todos', id, 'status', newStatus);
        renderObject('todos', id); // Re-render the view to show the change
        return;
    }


    // --- Modal-specific closing actions ---
    if (window.dashy.appState.isModalOpen) {
        if (target.closest('.cancel-modal-btn')) {
            closeModal();
        }
        return;
    }

    // --- Actions that ONLY happen when modal is closed ---
    const currentlyEditingKv = document.querySelector('#app-panel-content .kv-edit-mode');
    if (currentlyEditingKv && !currentlyEditingKv.contains(target)) {
        saveKeyValueRow(currentlyEditingKv);
    }

    if (target.closest('.app-panel-header') || target.closest('#bottom-nav')) {
        if (target.closest('#add-new-button')) {
            renderAddForm(target.closest('#add-new-button').dataset.type);
        } else if (target.closest('#app-title')) {
            renderDashboardView();
        } else if(target.closest('#bottom-nav')) {
            handleBottomNavClick(e);
        }
        return;
    }

    if (target.closest('#app-panel-content')) {
        if (target.closest('.filter-tag')) {
            const tag = target.closest('.filter-tag');
            tag.classList.toggle('active');
            toggleCustomObjectFilter(tag.dataset.type);
            loadFilteredItems('custom_objects');
            return;
        }
        if (target.closest('.link-item:not(.image-grid .link-item)')) {
            if (!target.closest('.unlink-btn')) renderObject(target.closest('.link-item').dataset.table, target.closest('.link-item').dataset.id);
        }
        else if (target.closest('.image-grid .link-item img')) {
            renderObject(target.closest('.link-item').dataset.table, target.closest('.link-item').dataset.id);
        }
        else if (target.closest('.list-item') && !target.closest('.todo-list-status')) { renderObject(target.closest('.list-item').dataset.table, target.closest('.list-item').dataset.id); }
        else if (target.closest('.search-results-list > li')) { await handleSearchItemClick(target.closest('li')); }
        else if (target.closest('.custom-type-results > li')) { handleCustomTypeClick(target.closest('li')); }
        else if (target.closest('.unlink-btn')) { await handleUnlinkClick(target); }
        else if (target.closest('.delete-object-btn')) { await handleDeleteClick(target); }
        else if (target.closest('.editable-title')) { activateInlineEdit(target.closest('.editable-title')); }
        else if (target.closest('.create-link-btn')) { renderOnTheFlyForm(target.closest('.create-link-btn').dataset.type); }
        else if (target.closest('.show-completed-todos-btn')) {
            const container = target.previousElementSibling;
            if (container && container.classList.contains('completed-todos-container')) {
                container.classList.remove('hidden');
                target.classList.add('hidden');
            }
            return;
        }
    }
}

async function handleGlobalSubmit(e) {
    e.preventDefault();

    const form = e.target;
    const type = form.dataset.type;
    const formData = new FormData(form);

    // The main 'Add New' form
    if (form.id === 'add-form') {
        const links = getSelectedLinks(form.querySelector('.add-link-form'));
        formData.append('links', JSON.stringify(links));
        try {
            const result = await api.createObject(type, formData);
            const createdItems = Array.isArray(result) ? result : [result];

            createdItems.forEach(item => {
                if (item.table === 'places') {
                    window.dashy.addMarkerToMap(item, true);
                }
            });

            let expectedTable = type === 'person' ? 'people' : `${type}s`;
            if (['image', 'other_file', 'custom_object'].includes(type)) expectedTable = `${type}s`;
            if (type === 'custom_object') expectedTable = 'custom_objects';
            if (type === 'other_file') expectedTable = 'files';


            const primaryItem = createdItems.find(item => item.table === expectedTable) || createdItems[0];
            if (primaryItem) {
                renderObject(primaryItem.table, primaryItem.id);
            } else {
                renderDashboardView();
            }
        } catch (error) { console.error(error); alert(`Error: ${error.message}`); }
    }

    // The 'On-the-fly' form in the modal
    if (form.id === 'on-the-fly-add-form') {
        try {
            const result = await api.createObject(type, formData);
            const createdItems = Array.isArray(result) ? result : [result];

            createdItems.forEach(item => {
                if (item.table === 'places') window.dashy.addMarkerToMap(item, true);
            });

            let expectedTable = `${type}s`;
            if (type === 'person') expectedTable = 'people';
            if (type === 'custom_object') expectedTable = 'custom_objects';
            if (type === 'other_file') expectedTable = 'files';

            const allPrimaryItems = createdItems.filter(item => item.table === expectedTable);

            if (allPrimaryItems.length > 0) {
                const objectViewContext = document.querySelector('.object-view');
                const addFormContext = document.getElementById('add-form');

                for (const primaryItem of allPrimaryItems) {
                    if (objectViewContext) { // Linking to an existing object we are viewing
                        const source = objectViewContext.dataset;
                        const target = primaryItem;
                        await api.post('/link', { source_id: source.id, source_table: source.table, target_id: target.id, target_table: target.table });
                        // Instead of adding to the list, we just re-render the view to get all the new grouping logic
                        renderObject(source.table, source.id);
                    } else if (addFormContext) { // Linking to a new object we are creating
                        const linkForm = addFormContext.querySelector('.add-link-form');
                        if (linkForm) addLinkToForm(primaryItem, linkForm);
                    }
                }
            }
            closeModal();
        } catch (error) { console.error(error); alert(`Error creating linked item: ${error.message}`); }
    }
}

async function handleGlobalChange(e) {
    const target = e.target;
    if (target.matches('#todo-status')) { // In object view
        const id = target.dataset.id;
        const newStatus = target.checked ? 1 : 0;
        await api.updateObject('todos', id, 'status', newStatus);
        target.nextElementSibling.textContent = newStatus ? 'Complete' : 'Incomplete';
        document.querySelector('.object-view-header h2')?.classList.toggle('completed', target.checked);
    } else if (target.matches('.todo-list-status input')) { // In list view
        const id = target.dataset.id;
        const newStatus = target.checked ? 1 : 0;
        await api.updateObject('todos', id, 'status', newStatus);
        target.closest('.list-item').querySelector('.item-title').classList.toggle('completed', target.checked);
    } else if (target.matches('.custom-file-input')) { // Custom file input
        const fileListEl = target.parentElement.querySelector('.file-list');
        if (!fileListEl) return;

        fileListEl.innerHTML = '';
        if (target.files.length > 0) {
            for (const file of target.files) {
                const li = document.createElement('li');
                li.textContent = file.name;
                fileListEl.appendChild(li);
            }
        }
    }
}

async function handleFocusIn(e) {
    if (e.target.matches('.custom-type-search-input')) {
        const input = e.target;
        const resultsList = input.nextElementSibling;
        const allTypes = await api.getCustomObjectTypes();
        resultsList.innerHTML = allTypes.map(t => `<li data-type-name="${t}">${formatObjectType(t)}</li>`).join('');
        resultsList.style.display = 'block';
    }
}

async function handleContentPanelInput(e) {
    if (e.target.matches('#dashboard-search-input')) {
        const input = e.target;
        const resultsList = document.getElementById('dashboard-search-results');
        const term = input.value.trim();

        if (term.length < 3) {
            resultsList.innerHTML = '';
            resultsList.style.display = 'none';
            return;
        }

        const results = await api.searchObjects(term, 25);
        resultsList.style.display = 'block';
        if (results.length > 0) {
            resultsList.innerHTML = results
                .map(r => `<li data-id="${r.id}" data-table="${r.table}" data-title="${r.title}"><i class="fas ${getIconForTable(r.table)}"></i> ${r.title}</li>`).join('');
        } else {
            resultsList.innerHTML = '<li style="padding: 0.75rem; color: var(--text-tertiary);">No results found</li>';
        }
        return;
    }

    if (e.target.matches('.link-search-input')) {
        const searchTerm = e.target.value;
        const resultsList = e.target.nextElementSibling;
        const objectView = e.target.closest('.object-view');
        const mainForm = e.target.closest('#add-form');
        let existingLinks = [];
        if (objectView) {
            existingLinks = Array.from(objectView.querySelectorAll('.links-list .link-item, .linked-items-preview .linked-item-tag')).map(el => el.dataset.linkId || `${el.dataset.table}:${el.dataset.id}`);
            const currentObjectId = objectView.dataset.id;
            existingLinks.push(`${objectView.dataset.table}:${currentObjectId}`);
        } else if (mainForm) {
            existingLinks = getSelectedLinks(mainForm);
        }

        if (searchTerm.length < 2) { resultsList.innerHTML = ''; return; }
        const results = await api.searchObjects(searchTerm);
        resultsList.innerHTML = results
            .filter(r => !existingLinks.includes(`${r.table}:${r.id}`))
            .map(r => `<li data-id="${r.id}" data-table="${r.table}" data-title="${r.title}"><i class="fas ${getIconForTable(r.table)}"></i> ${r.title}</li>`).join('');
    } else if (e.target.matches('.custom-type-search-input')) {
        const input = e.target;
        const searchTerm = input.value.toLowerCase();
        const resultsList = input.nextElementSibling;

        const allTypes = await api.getCustomObjectTypes();
        const filteredTypes = searchTerm ? allTypes.filter(t => t.toLowerCase().includes(searchTerm)) : allTypes;

        resultsList.innerHTML = filteredTypes.map(t => `<li data-type-name="${t}">${formatObjectType(t)}</li>`).join('');
        resultsList.style.display = filteredTypes.length > 0 ? 'block' : 'none';
    }
}

function handleKeyDown(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        if (e.target.classList.contains('inline-edit-input')) { e.preventDefault(); e.target.blur(); }
        if (e.target.closest('.kv-edit-mode') && !e.target.matches('textarea')) { e.preventDefault(); saveKeyValueRow(e.target.closest('li')); }
    } else if (e.key === 'Escape') {
        if (e.target.classList.contains('inline-edit-input')) e.target.blur();
        if (e.target.closest('.kv-edit-mode')) cancelEditKeyValueRow(e.target.closest('li'));
    }
}

function handleFocusOut(e) {
    if (e.target.matches('#dashboard-search-input')) {
        setTimeout(() => {
            const resultsList = document.getElementById('dashboard-search-results');
            if (resultsList && !resultsList.matches(':hover')) {
                resultsList.style.display = 'none';
            }
        }, 150);
        return;
    }
    if (e.target.matches('.inline-edit-input')) {
        saveInlineEdit(e.target);
    }
    if (e.target.closest('.kv-edit-mode') && !e.target.closest('.kv-edit-mode').contains(e.relatedTarget)) {
        saveKeyValueRow(e.target.closest('.kv-edit-mode'));
    }
    if (e.target.matches('.custom-type-search-input')) {
        setTimeout(() => {
            const resultsList = e.target.nextElementSibling;
            if (resultsList && !resultsList.matches(':hover')) {
                resultsList.style.display = 'none';
            }
        }, 150);
    }
}

function handleInfiniteScroll(e) {
    if (!window.dashy.appState.currentView?.type?.includes('list')) return;
    const { scrollTop, scrollHeight, clientHeight } = e.target;
    if (scrollHeight - scrollTop - clientHeight < 250) {
        loadMoreItems();
    }
}

function handleBottomNavClick(e) {
    const btn = e.target.closest('.nav-btn');
    if (btn) {
        document.querySelectorAll('#bottom-nav .nav-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const type = btn.dataset.type;
        if (type === 'dashboard') {
            renderDashboardView();
        } else {
            renderListView(type);
        }
    }
}

function handleMapClickForForm(e) {
    const { lat, lng } = e.detail;
    const latlngStr = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;

    const idPrefix = window.dashy.appState.isModalOpen ? 'otf-' : '';
    document.getElementById(`${idPrefix}latlng-display`)?.setAttribute('value', latlngStr);
    document.getElementById(`${idPrefix}lat`)?.setAttribute('value', lat);
    document.getElementById(`${idPrefix}lng`)?.setAttribute('value', lng);
}

async function handleSearchItemClick(li) {
    if (li.closest('#dashboard-search-results')) {
        renderObject(li.dataset.table, li.dataset.id);
        const searchInput = document.getElementById('dashboard-search-input');
        const resultsList = document.getElementById('dashboard-search-results');
        if (searchInput) searchInput.value = '';
        if (resultsList) resultsList.style.display = 'none';
        return;
    }

    if (li.closest('.custom-type-results')) {
        handleCustomTypeClick(li);
        return;
    }

    const linkForm = li.closest('.add-link-form');
    const objectView = li.closest('.object-view');
    const target = { id: li.dataset.id, table: li.dataset.table, title: li.dataset.title };

    if (objectView) {
        const source = objectView.dataset;
        await api.post('/link', { source_id: source.id, source_table: source.table, target_id: target.id, target_table: target.table });
        renderObject(source.table, source.id); // Re-render to show new link correctly
    } else {
        addLinkToForm(target, linkForm);
    }
    linkForm.querySelector('.link-search-input').value = '';
    li.parentElement.innerHTML = '';
}

function handleCustomTypeClick(li) {
    const container = li.closest('.custom-type-search-container');
    const input = container.querySelector('.custom-type-search-input');
    const resultsList = li.parentElement; // Get a reference to the parent (the <ul>)

    input.value = li.dataset.typeName; // Set the input value

    resultsList.innerHTML = ''; // Clear the list
    resultsList.style.display = 'none'; // Hide the list
}

async function handleUnlinkClick(target) {
    const source = target.closest('.object-view').dataset;
    const linkedItem = target.closest('.link-item');
    const targetData = linkedItem.dataset;
    if (confirm('Are you sure you want to unlink this item?')) {
        await api.unlinkObjects(source, targetData);
        // Re-render the view to show the updated links
        renderObject(source.table, source.id);
    }
}

async function handleDeleteClick(target) {
    const { id, table } = target.closest('.object-view').dataset;
    if (confirm('Are you sure you want to delete this object and all its links? This cannot be undone.')) {
        await api.deleteObject(table, id);
        if (table === 'places') window.dashy.removeMarkerFromMap(id);
        renderDashboardView();
    }
}

function activateInlineEdit(span) {
    if (span.querySelector('input')) return;
    const originalText = span.textContent;
    span.dataset.original = originalText;
    span.innerHTML = `<input type="text" value="${originalText}" class="inline-edit-input">`;
    const input = span.querySelector('input');
    input.focus();
    input.select();
}

async function saveInlineEdit(input) {
    const span = input.parentElement;
    if (!span || !span.classList.contains('editable-title') || !span.closest('.object-view')) return;

    const { id, table } = span.closest('.object-view').dataset;
    const newValue = input.value.trim();
    const originalValue = span.dataset.original;

    span.innerHTML = originalValue; // Revert to span to avoid losing content on failed API call

    if (newValue && newValue !== originalValue) {
        try {
            const result = await api.updateObject(table, id, 'title', newValue);
            span.textContent = result.newValue;
        } catch (e) {
            console.error(e);
            alert(`Error: ${e.message}`);
            span.textContent = originalValue; // Restore original on failure
        }
    } else {
        span.textContent = originalValue;
    }
}

function addKeyValueRow(target) {
    const container = target.closest('.form-group') || target.closest('.section') || target.closest('.form-container');
    const list = container.querySelector('.kv-list');
    if (!list || list.querySelector('.kv-edit-mode.new-kv')) return;
    const li = document.createElement('li');
    li.className = 'kv-edit-mode new-kv';
    li.innerHTML = `<input type="text" class="key-input" placeholder="Key">
                    <input type="text" class="value-input" placeholder="Value">
                    <div class="actions"><button type="button" class="save-kv-button action-button" title="Save"><i class="fas fa-check"></i></button></div>`;
    list.appendChild(li);
    li.querySelector('.key-input').focus();
}

function editKeyValueRow(li) {
    if (document.querySelector('.kv-edit-mode')) return;
    const key = li.querySelector('.key').textContent;
    const value = li.querySelector('.value').textContent;
    li.classList.add('kv-edit-mode');
    li.dataset.originalKey = key;
    li.dataset.originalValue = value;
    li.innerHTML = `<input type="text" class="key-input" value="${key}">
                    <input type="text" class="value-input" value="${value}">
                    <div class="actions"><button type="button" class="save-kv-button action-button" title="Save"><i class="fas fa-check"></i></button></div>`;
    li.querySelector('.key-input').focus();
}

async function saveKeyValueRow(li) {
    const keyInput = li.querySelector('.key-input');
    const valueInput = li.querySelector('.value-input');
    if (!keyInput || !valueInput) return;

    const key = keyInput.value.trim();
    const value = valueInput.value.trim();
    const isNewInForm = !li.closest('.object-view');

    if (!key) {
        cancelEditKeyValueRow(li);
        return;
    }

    if (isNewInForm) {
        li.classList.remove('kv-edit-mode', 'new-kv');
        li.innerHTML = `<input type="hidden" name="kv_key" value="${key}"><input type="hidden" name="kv_value" value="${value}">
                        <span class="key">${key}</span><span class="value">${value}</span><div class="actions"><button type="button" class="edit-kv-button action-button"><i class="fas fa-pencil-alt"></i></button><button type="button" class="delete-kv-button action-button"><i class="fas fa-trash"></i></button></div>`;
        return;
    }

    const { id, table } = li.closest('.object-view').dataset;
    const kvId = li.dataset.kvId;
    try {
        if (kvId) {
            await api.patch(`/kv/${kvId}`, { key, value });
        } else {
            const newKv = await api.post(`/object/${table}/${id}/kv`, { key, value });
            li.dataset.kvId = newKv.id;
        }
        li.classList.remove('kv-edit-mode', 'new-kv');
        li.innerHTML = `<span class="key">${key}</span><span class="value">${value}</span><div class="actions"><button class="edit-kv-button action-button"><i class="fas fa-pencil-alt"></i></button><button class="delete-kv-button action-button"><i class="fas fa-trash"></i></button></div>`;
    } catch (e) {
        console.error(e);
        alert(`Error saving detail: ${e.message}`);
        cancelEditKeyValueRow(li);
    }
}

function cancelEditKeyValueRow(li) {
    if (li.classList.contains('new-kv')) {
        li.remove();
        return;
    }
    li.classList.remove('kv-edit-mode');
    li.innerHTML = `<span class="key">${li.dataset.originalKey}</span><span class="value">${li.dataset.originalValue}</span><div class="actions"><button class="edit-kv-button action-button"><i class="fas fa-pencil-alt"></i></button><button class="delete-kv-button action-button"><i class="fas fa-trash"></i></button></div>`;
}

async function deleteKeyValueRow(li) {
    const isNewInForm = !li.dataset.kvId;
    if (isNewInForm) {
        li.remove();
        return;
    }
    if (confirm('Are you sure you want to delete this detail?')) {
        await api.del(`/kv/${li.dataset.kvId}`);
        li.remove();
    }
}
File /public/js/ui/forms.js:
import { contentPanel, getIconForTable, formatObjectType, openModal } from './helpers.js';
import * as api from '../api.js';
import { removeTempMarker } from '../main.js';

/**
 * Generates standardized form fields for any object type.
 * @param {string} type - The type of object (e.g., 'place', 'person').
 * @param {boolean} isModal - If true, prefixes IDs to prevent conflicts.
 * @returns {Promise<string>} A string of HTML for the form fields.
 */
async function generateFormFields(type, isModal = false) {
    let html = '';
    const p = isModal ? 'otf-' : ''; // Prefix for element IDs in modal

    switch (type) {
        case 'place':
            html += `<div class="form-group"><label for="${p}title">Title</label><input type="text" id="${p}title" name="title" required></div>`;
            html += `<div class="form-group"><label for="${p}latlng-display">Location (click on map)</label><input type="text" id="${p}latlng-display" readonly placeholder="Click on map to set coordinates" required>
                     <input type="hidden" name="lat" id="${p}lat"><input type="hidden" name="lng" id="${p}lng"></div>`;
            break;
        case 'person':
            html += `<div class="form-group"><label for="${p}title">Name</label><input type="text" id="${p}title" name="title" required></div>`;
            break;
        case 'interaction':
            html += `<div class="form-group"><label for="${p}title">Description</label><textarea id="${p}title" name="title" required></textarea></div>`;
            html += `<div class="form-group"><label for="${p}interaction_date">Date</label><input type="date" id="${p}interaction_date" name="interaction_date" value="${new Date().toISOString().slice(0,10)}" required></div>`;
            html += `<div class="form-group"><label for="${p}mood">Mood (-100 to 100)</label><input type="range" id="${p}mood" name="mood" min="-100" max="100" value="0"></div>`;
            break;
        case 'custom_object':
            html += `<div class="form-group"><label for="${p}title">Title</label><input type="text" id="${p}title" name="title" required></div>`;
            html += `<div class="form-group custom-type-search-container">
                        <label for="${p}object_type">Type</label>
                        <input type="text" id="${p}object_type" name="object_type" class="custom-type-search-input" placeholder="Enter or select a type" required autocomplete="off">
                        <ul class="search-results-list custom-type-results"></ul>
                     </div>`;
            html += `<div class="form-group"><label for="${p}mood">Mood (-100 to 100)</label><input type="range" id="${p}mood" name="mood" min="-100" max="100" value="0"></div>`;
            break;
        case 'todo':
            html += `<div class="form-group"><label for="${p}title">To-Do Item</label><input type="text" id="${p}title" name="title" required></div>`;
            html += `<input type="hidden" name="status" value="0">`; // Default to incomplete
            break;
        case 'image':
        case 'other_file':
            const isImage = type === 'image';
            const accept = isImage ? 'image/jpeg,image/png,image/webp,image/gif,image/avif' : '';
            const labelText = isImage ? 'Select Image(s)' : 'Select File(s)';
            html += `<div class="form-group">
                        <label>${labelText}</label>
                        <div class="custom-file-input-container">
                            <input type="file" name="files" id="${p}files" class="custom-file-input" accept="${accept}" multiple required>
                            <label for="${p}files" class="button"><i class="fas fa-upload"></i> Choose Files</label>
                            <ul class="file-list"></ul>
                        </div>
                     </div>`;
            break;
    }

    if (['place', 'person', 'interaction', 'custom_object', 'todo'].includes(type)) {
        html += `<div class="form-group"><label>Custom Details</label><ul class="kv-list"></ul><button type="button" class="add-kv-button button"><i class="fas fa-plus"></i> Add Detail</button></div>`;
    }
    return html;
}

/**
 * Renders the main form in the content panel for creating a new object.
 * @param {string} type - The type of object to create.
 */
export async function renderAddForm(type) {
    window.dashy.appState.currentView = { type: 'form', formType: type };
    if (type !== 'place') removeTempMarker();

    const formFieldsHtml = await generateFormFields(type, false);
    const formTitle = `Add New ${formatObjectType(type)}`;

    contentPanel.innerHTML = `
        <div class="form-container">
            <h2><i class="fas ${getIconForTable(type)}"></i> ${formTitle}</h2>
            <form id="add-form" data-type="${type}" autocomplete="off">
                ${formFieldsHtml}
                <div class="form-group"><label>Link to Other Items</label>${renderAddLinkForm()}</div>
                <button type="submit" class="button button-primary"><i class="fas fa-check"></i> Create ${formatObjectType(type)}</button>
            </form>
        </div>`;
}

/**
 * Renders a form in a modal for creating a new item "on-the-fly" to link it.
 * @param {string} type - The type of object to create.
 */
export async function renderOnTheFlyForm(type) {
    window.dashy.appState.modalFormType = type;
    const formFields = await generateFormFields(type, true);
    const modalHtml = `
        <div class="modal-header">
            <h2><i class="fas ${getIconForTable(type)}"></i> Add New ${formatObjectType(type)}</h2>
            <button class="cancel-modal-btn button button-danger"><i class="fas fa-times"></i> Cancel</button>
        </div>
        <div class="modal-body">
            <div class="form-container">
                <form id="on-the-fly-add-form" data-type="${type}" autocomplete="off">
                    ${formFields}
                    <button type="submit" class="button button-primary"><i class="fas fa-plus"></i> Create & Link</button>
                </form>
            </div>
        </div>
    `;
    openModal(modalHtml);
    if (type === 'place') {
        const mapCenter = window.dashy.appState.map.getCenter();
        const event = new CustomEvent('map-clicked-for-form', { detail: mapCenter });
        window.dispatchEvent(event);
    }
}

/**
 * Renders the UI for adding links to a form.
 * @returns {string} HTML string for the link creation section.
 */
export function renderAddLinkForm() {
    return `<div class="add-link-form">
        <input type="text" class="link-search-input" placeholder="Search to link existing items...">
        <ul class="search-results-list"></ul>
        <div class="linked-items-preview"></div>
        <p style="text-align: center; color: var(--text-tertiary); margin: 1rem 0;">Or create a new item to link:</p>
        <div class="link-creation-options">
            <button type="button" class="create-link-btn button" data-type="place" title="Create & Link Place"><i class="fas fa-map-marker-alt"></i></button>
            <button type="button" class="create-link-btn button" data-type="person" title="Create & Link Person"><i class="fas fa-user"></i></button>
            <button type="button" class="create-link-btn button" data-type="todo" title="Create & Link To-Do"><i class="fas fa-check-square"></i></button>
            <button type="button" class="create-link-btn button" data-type="interaction" title="Create & Link Interaction"><i class="fas fa-shuffle"></i></button>
            <button type="button" class="create-link-btn button" data-type="custom_object" title="Create & Link Custom Object"><i class="fas fa-tag"></i></button>
            <button type="button" class="create-link-btn button" data-type="image" title="Create & Link Image"><i class="fas fa-image"></i></button>
            <button type="button" class="create-link-btn button" data-type="other_file" title="Create & Link File"><i class="fas fa-file-alt"></i></button>
        </div>
    </div>`;
}

/**
 * Adds a visual tag for a linked item to a form's preview area.
 * @param {{table: string, id: string, title: string}} link - The object to link.
 * @param {HTMLElement} contextElement - The form element containing the link preview area.
 */
export function addLinkToForm(link, contextElement) {
    if (!contextElement) return;
    const linkId = `${link.table}:${link.id}`;
    const previewContainer = contextElement.querySelector('.linked-items-preview');
    if (!previewContainer) return;

    const existing = previewContainer.querySelector(`[data-link-id="${linkId}"]`);
    if (existing) return;

    const tag = document.createElement('span');
    tag.className = 'linked-item-tag';
    tag.dataset.linkId = linkId;
    tag.innerHTML = `<i class="fas ${getIconForTable(link.table)}"></i> ${link.title} <button type="button" class="remove-link-tag">&times;</button>`;

    tag.querySelector('.remove-link-tag').addEventListener('click', (e) => {
        e.preventDefault();
        tag.remove();
    });

    previewContainer.appendChild(tag);
}

/**
 * Retrieves all selected link IDs from a form's preview area.
 * @param {HTMLElement} contextElement - The form element.
 * @returns {string[]} An array of link IDs in the format 'table:id'.
 */
export function getSelectedLinks(contextElement) {
    const previewContainer = contextElement.querySelector('.linked-items-preview');
    if (!previewContainer) return [];
    return Array.from(previewContainer.querySelectorAll('.linked-item-tag')).map(tag => tag.dataset.linkId);
}
File /public/js/ui/helpers.js:
import { removeTempMarker } from '../main.js';

export const contentPanel = document.getElementById('app-panel-content');
export const modalOverlay = document.getElementById('modal-overlay');
export const modalContent = document.getElementById('modal-content');

export const getIconForTable = (table) => {
    const icons = {
        places: 'fa-map-marker-alt',
        people: 'fa-user',
        interactions: 'fa-shuffle',
        custom_objects: 'fa-tag',
        images: 'fa-image',
        files: 'fa-file-alt',
        todos: 'fa-check-square',
        dashboard: 'fa-home'
    };
    return icons[table] || 'fa-question-circle';
};

export const formatObjectType = (type) => {
    if (!type) return '';
    const specialCases = {
        'custom_objects': 'Custom Objects',
        'files': 'Files',
        'place': 'Place',
        'person': 'Person',
        'interaction': 'Interaction',
        'image': 'Image',
        'other_file': 'File',
        'custom_object': 'Custom Object',
        'todos': 'To-Dos',
        'todo': 'To-Do'
    };
    if (specialCases[type]) return specialCases[type];

    return type.replace(/_/g, ' ').split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
};

export const debounce = (func, delay) => {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
};

export function clearHighlight() {
    Object.values(window.dashy.appState.markers).forEach(m => {
        m._icon.classList.remove('highlighted');
    });
}

export function highlightMarker(marker) {
    marker._icon.classList.add('highlighted');
}

export function openModal(htmlContent) {
    modalContent.innerHTML = htmlContent;
    modalOverlay.classList.remove('hidden');
    window.dashy.appState.isModalOpen = true;
}

export function closeModal() {
    modalOverlay.classList.add('hidden');
    modalContent.innerHTML = '';
    window.dashy.appState.isModalOpen = false;
    removeTempMarker();
}
File /public/js/ui/main_view.js:
import * as api from '../api.js';
import { contentPanel, getIconForTable, formatObjectType, highlightMarker, clearHighlight } from './helpers.js';
import { renderAddLinkForm } from './forms.js';

let isLoadingMore = false;
let activeCustomObjectFilters = new Set();

export function toggleCustomObjectFilter(type) {
    if (activeCustomObjectFilters.has(type)) {
        activeCustomObjectFilters.delete(type);
    } else {
        activeCustomObjectFilters.add(type);
    }
}

const listToFormTypeMap = {
    places: 'place',
    people: 'person',
    interactions: 'interaction',
    custom_objects: 'custom_object',
    images: 'image',
    files: 'other_file',
    todos: 'todo',
    recent: 'place' // Default for dashboard 'Add New'
};

export function renderWelcomeMessage() {
    window.dashy.appState.currentView = { type: 'welcome' };
    contentPanel.innerHTML = `
        <div class="welcome-message">
            <i class="fas fa-meteor"></i>
            <h2>Welcome to Dashy</h2>
            <p>This is your personal life dashboard. To get started, try adding a Place, a Person, or any other item using the navigation below.</p>
        </div>`;
    document.getElementById('add-new-button').classList.add('hidden');
    document.querySelectorAll('#bottom-nav .nav-btn').forEach(b => b.classList.remove('active'));
    document.querySelector('.nav-btn[data-type="dashboard"]').classList.add('active');
}

export async function renderDashboardView() {
    renderListView('recent');
}

export async function renderListView(type) {
    console.log(`Rendering list view for: ${type}`);
    if (type !== 'custom_objects') {
        activeCustomObjectFilters.clear();
    }
    window.dashy.appState.currentView = { type: 'list', listType: type, offset: 0, hasMore: true };

    const addNewButton = document.getElementById('add-new-button');
    const formType = listToFormTypeMap[type] || type;
    addNewButton.dataset.type = formType;
    addNewButton.querySelector('span').textContent = `Add ${formatObjectType(formType)}`;
    addNewButton.classList.remove('hidden');

    clearHighlight();

    const listTitle = (type === 'recent') ? 'Recent Items' : formatObjectType(type);
    const dashboardSearchHtml = type === 'recent' ? `
        <div class="dashboard-search-container">
            <input type="text" id="dashboard-search-input" placeholder="Search everywhere...">
            <ul class="search-results-list" id="dashboard-search-results" style="display: none;"></ul>
        </div>
    ` : '';

    contentPanel.innerHTML = `<div class="list-view-header"><h2><i class="fas ${getIconForTable(type)}"></i> ${listTitle}</h2>${dashboardSearchHtml}</div><div id="list-view-body"></div>`;
    const body = contentPanel.querySelector('#list-view-body');

    if (type === 'custom_objects') {
        const types = await api.getCustomObjectTypes();
        if (types.length > 0) {
            const filterTagsHtml = `
                <div class="filter-tags-container">
                    ${types.map(t => `<div class="filter-tag ${activeCustomObjectFilters.has(t) ? 'active' : ''}" data-type="${t}">${formatObjectType(t)}</div>`).join('')}
                </div>`;
            // Insert filters before the main body container
            body.insertAdjacentHTML('beforebegin', filterTagsHtml);
        }
    }

    body.innerHTML = `<ul class="items-list-view"></ul><div class="loader">Loading...</div>`;
    await loadFilteredItems(type);
}

export async function loadFilteredItems(type) {
    const listViewBody = document.getElementById('list-view-body');
    if (!listViewBody) return;

    // Reset UI and state for new filter application
    listViewBody.querySelector('.items-list-view').innerHTML = '';
    let loader = listViewBody.querySelector('.loader');
    if (!loader) {
        loader = document.createElement('div');
        loader.className = 'loader';
        listViewBody.appendChild(loader);
    }
    loader.textContent = 'Loading...';

    window.dashy.appState.currentView.offset = 0;
    window.dashy.appState.currentView.hasMore = true;
    isLoadingMore = false;

    try {
        let filters = {};
        if (type === 'custom_objects' && activeCustomObjectFilters.size > 0) {
            filters.types = Array.from(activeCustomObjectFilters);
        }
        const items = await api.getObjectsList(type, { filters });
        appendItemsToListView(items, type);
    } catch (error) {
        console.error(`Error fetching filtered list view for ${type}:`, error);
        listViewBody.innerHTML = `<p>Error loading items.</p>`;
    }
}

export async function loadMoreItems() {
    const currentView = window.dashy.appState.currentView;
    if (!currentView || !currentView.type.includes('list')) return;

    const { listType, offset, hasMore } = currentView;
    if (isLoadingMore || !hasMore) return;

    isLoadingMore = true;
    const newOffset = offset + 20;
    try {
        let filters = {};
        if (listType === 'custom_objects' && activeCustomObjectFilters.size > 0) {
            filters.types = Array.from(activeCustomObjectFilters);
        }
        const items = await api.getObjectsList(listType, { offset: newOffset, filters });
        if (items.length > 0) {
            appendItemsToListView(items, listType);
            window.dashy.appState.currentView.offset = newOffset;
        } else {
            window.dashy.appState.currentView.hasMore = false;
            const loader = contentPanel.querySelector('.loader');
            if (loader) loader.remove();
            console.log("End of list reached.");
        }
    } catch (error) {
        console.error('Failed to load more items:', error);
    } finally {
        isLoadingMore = false;
    }
}

function appendItemsToListView(items, type) {
    const list = contentPanel.querySelector('.items-list-view');
    const loader = contentPanel.querySelector('.loader');
    if (!list) return;

    if (list.children.length === 0 && items.length === 0) {
        if(loader) loader.textContent = 'No items found.';
        return;
    }

    const isRecentView = type === 'recent';
    const isTodoList = type === 'todos';
    const isImageView = type === 'images';

    if (isImageView && list) {
        list.classList.add('image-grid');
    }

    const itemsHtml = items.map(item => {
        let label = isRecentView ? formatObjectType(item.table) : '';
        if (item.table === 'custom_objects' && item.object_type) {
            label = formatObjectType(item.object_type);
        }

        let prefix = `<i class="fas ${getIconForTable(item.table)} fa-fw"></i>`;
        let titleClass = '';

        if (isTodoList) {
            const isChecked = item.status === 1;
            prefix = `<div class="todo-list-status"><input type="checkbox" id="todo-list-item-${item.id}" data-id="${item.id}" ${isChecked ? 'checked' : ''}></div>`;
            titleClass = isChecked ? 'completed' : '';
        }

        if(isImageView) {
            return `<li class="list-item" data-id="${item.id}" data-table="${item.table}"><img src="/data${item.file_path}" alt="${item.title}" loading="lazy"></li>`
        }

        return `
            <li class="list-item ${isTodoList ? 'todo-item' : ''}" data-id="${item.id}" data-table="${item.table}">
                <div class="item-title ${titleClass}">
                    ${prefix}
                    <span>${item.title}</span>
                </div>
                <div class="item-meta">
                    ${isRecentView ? `<span class="item-type-label">${label}</span>` : ''}
                </div>
            </li>`;
    }).join('');
    list.insertAdjacentHTML('beforeend', itemsHtml);

    if (loader) {
        if (items.length < 20) {
            loader.remove();
        } else {
            loader.textContent = 'Loading...';
        }
    }
}

export async function renderObject(table, id) {
    console.log(`Rendering object view for: ${table}:${id}`);
    window.dashy.appState.currentView = { type: 'object', table, id };
    document.getElementById('add-new-button').classList.add('hidden');
    document.querySelectorAll('#bottom-nav .nav-btn').forEach(b => b.classList.remove('active'));


    clearHighlight();

    if (window.dashy.appState.markers[id]) {
        highlightMarker(window.dashy.appState.markers[id]);
        window.dashy.appState.map.flyTo(window.dashy.appState.markers[id].getLatLng(), 15);
    } else {
        const objectForMap = await api.getObject(table, id);
        const linkedPlace = objectForMap.links.find(l => l.table === 'places');
        if (linkedPlace && window.dashy.appState.markers[linkedPlace.id]) {
            highlightMarker(window.dashy.appState.markers[linkedPlace.id]);
            window.dashy.appState.map.flyTo(window.dashy.appState.markers[linkedPlace.id].getLatLng(), 15);
        }
    }

    contentPanel.innerHTML = '<div class="loader">Loading...</div>';
    try {
        const object = await api.getObject(table, id);

        const links = object.links;
        const groupedLinks = { todos: [], images: [], files: [], people: [], interactions: [], custom_objects: [], places: [] };
        links.forEach(link => {
            if (groupedLinks[link.table]) {
                groupedLinks[link.table].push(link);
            }
        });

        const sectionOrder = ['todos', 'images', 'files', 'people', 'interactions', 'custom_objects', 'places'];
        let groupedLinksHtml = '';

        sectionOrder.forEach(sectionKey => {
            const items = groupedLinks[sectionKey];
            if (items.length === 0) return;

            const sectionTitle = formatObjectType(sectionKey);
            let sectionContent = '';

            if (sectionKey === 'todos') {
                items.sort((a, b) => a.status - b.status); // Incomplete (0) first
                const incomplete = items.filter(t => t.status === 0);
                const complete = items.filter(t => t.status === 1);

                const renderTodo = (todo) => `<li class="link-item" data-id="${todo.id}" data-table="${todo.table}"><span class="link-title ${todo.status === 1 ? 'completed' : ''}"><i class="fas fa-check-square"></i> <span>${todo.title}</span></span><button class="unlink-btn action-button" title="Unlink Item"><i class="fas fa-times"></i></button></li>`;

                let listHtml = incomplete.map(renderTodo).join('');
                if (complete.length > 0) {
                    const completedContainerClass = complete.length > 5 ? 'completed-todos-container hidden' : 'completed-todos-container';
                    listHtml += `<div class="${completedContainerClass}">${complete.map(renderTodo).join('')}</div>`;
                    if (complete.length > 5) {
                        listHtml += `<button class="show-completed-todos-btn button">${`Display ${complete.length} complete element` + (complete.length > 1 ? 's' : '')}</button>`;
                    }
                }
                sectionContent = `<ul class="links-list">${listHtml}</ul>`;

            } else if (sectionKey === 'images') {
                const imageItemsHtml = items.map(l =>
                    `<li class="link-item" data-id="${l.id}" data-table="${l.table}">
                        <img src="/data${l.file_path}" alt="${l.title}" loading="lazy">
                        <button class="unlink-btn action-button" title="Unlink Item"><i class="fas fa-times"></i></button>
                    </li>`
                ).join('');
                sectionContent = `<ul class="links-list image-grid">${imageItemsHtml}</ul>`;

            } else {
                const itemsHtml = items.map(l =>
                    `<li class="link-item" data-id="${l.id}" data-table="${l.table}">
                        <span class="link-title"><i class="fas ${getIconForTable(l.table)}"></i> <span>${l.title}</span></span>
                        <button class="unlink-btn action-button" title="Unlink Item"><i class="fas fa-times"></i></button>
                    </li>`
                ).join('');
                sectionContent = `<ul class="links-list">${itemsHtml}</ul>`;
            }

            groupedLinksHtml += `
                <div class="section link-section">
                    <div class="section-header"><h3><i class="fas ${getIconForTable(sectionKey)}"></i> ${sectionTitle}</h3></div>
                    ${sectionContent}
                </div>
            `;
        });

        let detailsHtml = '';
        let headerClass = '';

        if (table === 'interactions' || table === 'custom_objects') {
            const moodPercentage = (object.mood + 100) / 2;
            detailsHtml += `<div class="detail-item"><i class="fas fa-heart"></i> Mood <div class="mood-bar"><div class="thumb" style="transform: scaleX(${moodPercentage / 100});"></div></div></div>`;
        }
        if (table === 'interactions') {
            detailsHtml += `<div class="detail-item"><i class="fas fa-calendar-alt"></i> ${object.interaction_date}</div>`;
        }
        if (table === 'todos') {
            headerClass = object.status === 1 ? 'completed' : '';
            const isComplete = object.status === 1;
            detailsHtml += `
                <button 
                    class="button todo-status-button ${isComplete ? 'complete' : 'incomplete'}" 
                    data-id="${object.id}" 
                    data-current-status="${object.status}">
                    <i class="fas ${isComplete ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                    <span>${isComplete ? 'Complete' : 'Incomplete'}</span>
                </button>`;
        }

        const kvHtml = object.key_values.map(kv => `<li data-kv-id="${kv.id}"><span class="key">${kv.key}</span><span class="value">${kv.value}</span><div class="actions"><button class="edit-kv-button action-button"><i class="fas fa-pencil-alt"></i></button><button class="delete-kv-button action-button"><i class="fas fa-trash"></i></button></div></li>`).join('');
        const objectTypeDisplay = (table === 'custom_objects' && object.object_type) ? `<span class="object-type-display">${formatObjectType(object.object_type)}</span>` : '';
        const imagePreview = (table === 'images') ? `<img src="/data${object.file_path}" class="image-preview" alt="${object.title}">` : '';

        const headerActionsHtml = `
            <div class="header-actions" style="display:flex; gap:0.5rem;">
                 ${table === 'files' ? `<a href="/data${object.file_path}" download="${object.title}" class="button"><i class="fas fa-download"></i> Download</a>` : ''}
                 <button class="delete-object-btn button button-danger" title="Delete Object"><i class="fas fa-trash"></i></button>
            </div>`;


        contentPanel.innerHTML = `
            <div class="object-view" data-id="${id}" data-table="${table}">
                <div class="object-view-header">
                    <h2 class="${headerClass}"><i class="fas ${getIconForTable(table)}"></i> <span class="editable-title">${object.title}</span>${objectTypeDisplay}</h2>
                    ${headerActionsHtml}
                </div>

                ${imagePreview}
                
                <div class="section">
                    <div class="section-header">
                        <h3><i class="fas fa-list-ul"></i> Details</h3>
                        <button class="add-kv-button button"><i class="fas fa-plus"></i></button>
                    </div>
                    ${detailsHtml ? `<div style="margin-bottom: 1.5rem;">${detailsHtml}</div>` : ''}
                    <ul class="kv-list">${kvHtml}</ul>
                </div>
                
                ${groupedLinksHtml}

                <div class="section">
                    ${renderAddLinkForm()}
                </div>
            </div>`;
    } catch (error) {
        console.error(`Error rendering object ${table}:${id}`, error);
        contentPanel.innerHTML = `<p>Error loading item.</p>`;
    }
}

All of this works perfectly using node v20.3.0 (npm v9.6.7).

ou are an expert software developer tasked with converting an existing Node.js/Express web application into a full-featured, cross-platform desktop application for macOS, Windows, and Linux using Electron.

You will be provided with the full file structure and code for the original web application, named "dashy". Your task is to modify the existing files and create new ones to meet the following specific requirements. You must not use any code signing or software signature mechanisms, as the application is open source and relies on user trust.

Here is a detailed breakdown of the required implementation:

1. Core Electron Integration & Environment Setup

Enforce Node.js Version: The original project was built using Node.js v20.3.0 and npm v9.6.7. You must enforce this to ensure dependency and build consistency.
Create a .nvmrc file in the project root containing v20.3.0.
Add an engines field to package.json specifying {"node": "20.3.0", "npm": "9.6.7"}.
Integrate Electron Framework: Add electron, electron-builder, electron-updater, compare-versions, and electron-rebuild as project dependencies in package.json.
Create Core Files:
Create a main process entry point file, electron-main.js. This file will be responsible for creating the application window and managing all backend logic.
Create a preload.js script to securely expose Inter-Process Communication (IPC) channels to the frontend (renderer process).
Refactor Architecture:
Refactor the application away from the client-server model. The Express server (server.js) and its routes (app/routes.js) must be replaced with IPC handlers in the main process. Abstract the core business logic (e.g., database queries, file processing) into shared modules that can be called by these new IPC handlers.
Update the frontend API calls in /public/js/api.js to use window.electronAPI.invoke(...) to communicate with the main process instead of using fetch.
Handle file uploads (for images and other files) by using Electron's dialog to let the user select a file. The main process will then receive the file's path via IPC and must be responsible for copying that file into the appropriate application data directory ({data_folder}/images/ or {data_folder}/files/).
2. Native Dependencies & Cross-Platform HEIC Support

Acknowledge sharp as a critical native dependency. All subsequent steps must ensure it is correctly compiled with HEIC support for each target platform (Windows, macOS, Linux) and architecture (x64, arm64).
Developer Environment Documentation: Create a CONTRIBUTING.md or update the README.md file with a "Developer Prerequisites" section. This section must instruct developers on the system-level libraries they need to install on their local machine to successfully build sharp with libheif support. This includes, for example, libheif-dev on Debian/Ubuntu, libheif via Homebrew on macOS, and the necessary build tools on Windows.
Installation & Rebuild Configuration:
Configure package.json to ensure sharp attempts to build with libheif support during npm install. This may require setting platform-specific environment variables or npm config flags prior to installation.
Add a postinstall script to package.json: "postinstall": "electron-rebuild". This ensures that after every npm install, sharp and any other native modules are correctly rebuilt against the project's version of Electron for the local development environment.
Production Build Configuration (electron-builder):
In the build section of package.json, ensure electron-builder is configured to correctly handle and rebuild native modules for the target platform during packaging. Use the npmRebuild: true flag in the main build configuration to enforce this.
Specify that for cross-compiling (e.g., building for Linux on a macOS host), electron-builder should be configured to use a Docker container. This creates a predictable Linux environment where the necessary dependencies like libheif-dev can be installed, ensuring sharp is compiled correctly for the Linux target.
3. Data Persistence and Management

Default Data Location: The application must, by default, store all user data (the dashy.sqlite3 database, uploaded images, and files) in the safe, standard application data directory provided by Electron via app.getPath('userData').
Custom Data Location:
Implement a feature allowing the user to choose a custom folder for their data.
The selected custom path must be stored persistently in a config.json file located within the default app.getPath('userData') directory.
On startup, the application must read this config.json file. If a custom path is defined, all data operations must use that path. Otherwise, the default path should be used.
Provide the user access to this feature through the native application menu bar (File > Change Data Location...).
When the user selects a new data folder, the application must perform the following actions:
Securely move all existing data (the entire contents of the old data folder) to the new user-selected location.
After a successful move, update the config.json file with the new path.
Display a system dialog informing the user that the data has been moved successfully and that the application needs to restart for the change to take effect.
Automatically relaunch and quit the application.
4. Database Schema Migrations

Implement a robust, forward-only database migration system to handle schema updates between application versions without data loss.
Use SQLite's PRAGMA user_version to track the current version of the user's database schema.
In the application's code, define a target schema version number and an ordered collection of migration scripts.
On application startup, compare the database's user_version with the target version. If the database version is lower, apply all necessary migration scripts sequentially.
Crucially, all sequential migrations must be wrapped in a single database transaction to ensure that the process is atomic. If any migration script fails, the transaction must be rolled back to prevent database corruption.
5. Manual Update Notification System

Implement an in-app notification system for manual updates. Do not use electron-updater's automatic installation functionality.
On application startup, the app must fetch a JSON file from the specific URL: https://raw.githubusercontent.com/alvarofranz/dashy/refs/heads/main/version.json.
The application must compare its own version (app.getVersion()) with the version field from the fetched JSON file using a version comparison library that correctly handles semantic versioning.
If the fetched version is newer, the application must display a non-intrusive notification banner within the UI, informing the user that an update is available and displaying any release notes provided in the JSON file.
The notification banner must contain a "Download" button. When clicked, this button should use Electron's shell.openExternal to open the url specified in the fetched JSON file in the user's default web browser.
Also, add a "Check for Updates..." item to the native application menu bar that allows the user to trigger this check manually.
6. Application Packaging & Development Workflow

Development Script: Create an "electron:dev" script in package.json that uses nodemon to watch all main process files (electron-main.js, preload.js, app/) and automatically restart the Electron application on change. The main process code should also include a watcher for the /public directory to reload the renderer window on frontend file changes.
Packaging Configuration: Configure electron-builder via the build section in package.json. Set up build targets to generate installers for all three platforms: a dmg for macOS, an nsis installer for Windows, and AppImage and deb packages for Linux. Ensure the configuration points to the necessary icon files (.icns, .ico, .png) located in a /build directory.
No Code Signing: The build configuration must not contain any settings related to code signing, notarization, or publishers. The resulting application packages will be unsigned.

Do it with attention to detail and making sure you do not break anything and don't introduce regressions.

Give me ALL the FULL FINAL FILES and explain how to use.